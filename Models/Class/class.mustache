const dbpath = './Database/{{dbName}}'
var db = require('../Database/sqlite.js')(dbpath) 

class {{classTitle}} {
    constructor ({{classProperties}}) {
        {{{classConstructor}}}
        Object.defineProperty(this, '{{idField}}', {enumerable: true, writable: true});
    }

    /**
    * Função que permite obter todos os registos existentes na base de dados da entidade {{classTitle}}
    * @param {*} callback função que se pretende executar com os resultados obtidos da query
    */
    static all(callback){
        return db.all("SELECT * FROM {{classTitle}};", {{classTitle}}, callback);
    }

    /**
    * Função que permite obter o registo da base de dados com o id passado como argumento
    * @param {*} id id do registo que se pretende obter
    * @param {*} callback função que se pretende executar com o resultado obtido da query
    */
    static get(id, callback){
        return db.get("SELECT * FROM {{classTitle}} WHERE {{idField}} = ?;", [id], {{classTitle}}, callback);
    }
    
    
    {{#joins}}
    /**
    * Get with all inner joins
    */
    static getWithAllJoins(callback) {
        return db.all("SELECT {{classProperties}},{{joinsColumns}} FROM {{classTitle}} {{{joins}}};", {{classTitle}}, callback);
    }
    {{/joins}}

    {{#joinsById}}
    /**
    * Get all {{classTitle}}s with {{.}} id 
    */
    static getAllBy{{.}}(id, callback) {
        return db.all("SELECT * FROM {{classTitle}} Where {{.}}ID = ?;", [id], {{classTitle}}, callback);
    }
    {{/joinsById}}

    /**
    * Group by field
    */
    static getAllGroupBy(field, callback) {
        return db.all("SELECT * FROM {{classTitle}} GROUP BY ?;", [field], {{classTitle}}, callback);
    }

    /**
    * Group by field with innerjoins
    */
    static getAllGroupByWithInnerJoins(field, callback) {
        return db.all("SELECT {{classProperties}}, {{joinsColumns}} FROM {{classTitle}} {{{joins}}} GROUP BY ?;", [field], {{classTitle}}, callback);
    }

    /**
    * Função que permite eliminar o registo na tabela com o id passado como argumento
    * @param {*} id id do registo que se pretende eliminar
    * @param {*} callback função que se pretende executar com o resultado obtido da query
    */
    static delete(id,callback){
        return db.get("DELETE FROM {{classTitle}} WHERE {{idField}} = ?;", [id], callback);
    }   

    /**
    * Função que insere ou atualiza um registo consoante a existência ou não existência do registo na base de dados
    * @param {*} callback função que se pretende executar com o resultado obtido da query
    */
    save(callback){
        if(this.{{idField}}){   //Se existir valor no id fazemos update
        {{! o iterateProperties tem 3 chavetas para conseguirmos mostrar o caracter =  }}

            db.run("UPDATE {{classTitle}} SET {{{iterateProperties}}}", {{propertiesWithID}}, callback);

        } else {    //Caso contrário adiciona-se um novo campo a tabela
            db.run("INSERT INTO {{classTitle}} ({{classProperties}}) VALUES ({{iterateValuesForInsert}})", [{{iterateArrayForInsert}}] , callback);
            
            //db.run("SELECT last_insert_rowid()", [],(id) => {this.{{idField}} = id;});
        }
    }

}

module.exports = {{classTitle}};